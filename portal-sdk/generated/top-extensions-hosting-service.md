
<a name="extension-hosting-service"></a>
## Extension Hosting Service

Teams deploying UI for extensions with the classic cloud service model typically have to invest significant time upfront to onboard to MDS, setup compliant deployments across all data centers, configure cdn, storage and implement caching optimizations in their extension.
The process of setting up and maintaining this infrastructure can be high. By leveraging the extension hosting service, extension developers can host their extension UI in all data centers without investing heavily in the deployment infrastructure.
This is the primary reason more than 50% of the extensions have decided to migrate from legacy DIY deployment to extension hosting service.


<a name="why-use-extension-hosting-service"></a>
## Why use extension hosting service

1. Simple Deployments and hosting out of the box that
    1. Safe Deployment
    1. Geodistributes the extension to all data centers
    1. Use portal's MDS so no need to onboard to MDS
    1. Persistent caching, index page caching, manifest caching and all other optimizations that are implemented along the way.
1. Enhanced Monitoring
    1. Removes need for on call rotation for hosting specific issues as portal is now hosting. On call still required for dev code livesite issues
    1. We will provide full visibility into the health and activity for your extension
1. Reduced COGS
    1. No hosting COGS
    1. Reduced development cost – focus on building the domain specifics of your extension rather than spending time on figuring out deployment

<a name="why-use-extension-hosting-service-can-i-use-hosting-service-if-my-extension-has-server-side-code-or-controllers"></a>
#### Can I use hosting service if my extension has Server-Side Code (or Controllers) ?

Yes. In fact you can supplement your legacy DIY deployment infrastructure to use hosting service and deploy UI in safe-deploy compliant way.

1. In most cases Controllers are legacy and it is easy to get rid of Controllers. One advantage of getting rid of controllers is that all your clients such as Ibiza and powershell will now have consistent experience.
    In order to get rid of controllers you can follow either of these approach:
    1.	If the functionality is already available from another service
    1.	By Hosting serverside code within existing RP

1. If getting rid of Controllers is not a short terms task, you can deploy UI through hosting service by modifying the relative controller URLs used in client code to absolute URLS. Here is a sample Pull-request for cloud services extension: https://msazure.visualstudio.com/One/_git/AzureUX-CloudServices/commit/ac183c0ec197de7c7fd3e1eee1f7b41eb5f2dc8b

Post this code change, you can deploy the as a server-only service that will be behind Traffic Manager.

<a name="30-sec-overview"></a>
## 30-sec Overview

This section provides a quick 30-sec overview of how you deploy extension using hosting service

1. You integrate content unbundler, a tool shipped with framework, as part of your build. This tool generates a zip that has all the static files in your extension.
1. You upload zip file generated in Step #1 to a public read-only storage account owned by your team.
1. Hosting service polls the storage account, detects the new version and downloads the zip file in each data center within 5 minutes and starts serving the new version to customers around the world.

<a name="30-sec-overview-prerequisites-for-onboarding-hosting-service-for-all-extensions"></a>
### Prerequisites for onboarding hosting service for all extensions

1. **SDK Version**
    To generate the zip file during build process from your extension use Portal SDK 5.0.302.454 or above

    **NOTE**: If your team plans to use EV2 for uploading zip file to storage account, we recommend using Portal SDK 5.0.302.817 or above. We have recently some new features that makes it easier to use EV2 with hosting service.

1. **Build Output Format**

The content unbundler expects the build output of the extension project to be in a specific format.

1. All assemblies that are generated by your build should be in a directory called **bin**

1. Web.config should be in the same level as the **bin** directory

1. In short, the content unbundler should point at the same directory as you would point IIS at to load the extension.

<a name="30-sec-overview-prerequisites-for-onboarding-hosting-service-for-extensions-with-server-side-code-or-controllers"></a>
### Prerequisites for onboarding hosting service for extensions with server-side code (or Controllers)
    
Modify the relative controller URLs to absolute URLS. The Controllers will deploy a new server-only service that will be behind Traffic Manager.

Since this process is typically same across all extension you can leverage the pull-request for cloud services extension : [https://msazure.visualstudio.com/One/_git/AzureUX-CloudServices/commit/ac183c0ec197de7c7fd3e1eee1f7b41eb5f2dc8b](https://msazure.visualstudio.com/One/_git/AzureUX-CloudServices/commit/ac183c0ec197de7c7fd3e1eee1f7b41eb5f2dc8b)

<a name="30-sec-overview-step-by-step-onboarding"></a>
### Step-by-Step Onboarding

<a name="30-sec-overview-step-by-step-onboarding-step-1-update-isdevelopmentmode-to-false"></a>
#### Step 1: Update IsDevelopmentMode to false

Content unbundler requires  development mode be set to false to assign correct build version to the zip file.

Update IsDevelopmentMode in web.config to false.

```xml
    <add key="Microsoft.Portal.Extensions.<YourExtension>.ApplicationConfiguration.IsDevelopmentMode" value="false"/>
```

Here is an example of monitoring extension

```xml
    <add key="Microsoft.Portal.Extensions.MonitoringExtension.ApplicationConfiguration.IsDevelopmentMode" value="false"/>
```

If you wish to achieve this only on release builds a [web.Release.config transform](http://go.microsoft.com/fwlink/?LinkId=125889) can be used.

<a name="30-sec-overview-step-by-step-onboarding-step-2-install-microsoft-portal-tools-contentunbundler-and-import-targets"></a>
#### Step 2: Install Microsoft.Portal.Tools.ContentUnbundler and import targets

Microsoft.Portal.Tools.ContentUnbundler provides content unbundler tool that can be run against the extension assemblies to extract static content and bundles. 

a. If you installed via Visual Studio, NuGet package manager or NuGet.exe it will automatically add the following target. 

b. If you are using CoreXT global packages.config you will have to add the target to your .csproj manually 

```xml
<Import Project="$(PkgMicrosoft_Portal_Tools_ContentUnbundler)\build\Microsoft.Portal.Tools.ContentUnbundler.targets" />
```

<a name="30-sec-overview-step-by-step-onboarding-step-3-verify-if-your-build-has-a-version-number-set"></a>
#### Step 3: Verify if your build has a version number set

The zip file generated during the build should be named as BUILD_VERSION.zip, where BUILD_VERSION is the current version number of your build.


**For extensions using CoreXT**

Executing following command will prompt the version number
```
$>set CURRENT_BUILD_VERSION
```

In my case this prompts:

```
CURRENT_BUILD_VERSION=5.0.0.440
```

**For extensions using non-CoreXT**

There are multiple build systems used by teams. We think you understand your build system better than us. 
Once you have identified how to identify build version for your build system, feel free to send a PR to help other extension developers. 

** If your build does not have a version set **

If your build does not have a version number, you can add AssemblyInfo.cs to you project with following content. This will set the build version to 1.0.0.0

**NOTE**: Microsoft.Portal.Extensions.<YourExtension> here specifies the fully qualified name of **your** extension. Also, in this scenario the build version is hard-coded to 1.0.0.0

1. Add new file **AssemblyInfo.cs**

```xml
<Compile Include="AssemblyInfo.cs" />
```

2. Update **AssemblyInfo.cs** content

```cs
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------

using Microsoft.Portal.Framework;

[assembly: AllowEmbeddedContent("Microsoft.Portal.Extensions.<YourExtension>")]
[assembly: System.Reflection.AssemblyFileVersion("1.0.0.0")]
```

<a name="30-sec-overview-step-by-step-onboarding-step-4-environment-specific-configuration-files"></a>
#### Step 4:  <strong>Environment specific configuration files</strong>

In order to load your extension in a specific environments you will need to provide environment specific configuraiton file as an embedded resource in Content\Config\* directory. Here are example for each environment: 

**NOTE**
* The files need to be placed under **\Content\Config\**
* The file should be set as en EmbeddedResource, otherwise the file will not be included in the output that gets generated by the content unbundler.
* The files need to be named with the following convention: &lt;host&gt;.&lt;domain&gt;.json (e.g. portal.azure.com.json, ms.portal.azure.com.json)

For now, just add this empty file as embedded resource:
1. Dogfood: 
        Configuration file name should be df.onecloud.azure-test.net.json. 
    ```xml
    <EmbeddedResource Include="Content\Config\df.onecloud.azure-test.net.json" />
    ```

1. Production: 
        Configuration file name should be portal.azure.com.json. 
    ```xml
    <EmbeddedResource Include="Content\Config\portal.azure.com.json" />
    ```
	Production environment has 3 stamps

    1. RC   **rc.portal.azure.com**
    1. MPAC **ms.portal.azure.com**
    1. PROD **portal.azure.com**

    One single configuration file is enough for all three stamps.

1. Mooncake (portal.azure.cn): 
     Configuration file name should be portal.azure.cn.json

    ```xml
    <EmbeddedResource Include="Content\Config\portal.azure.cn.json" />
    ```     

1. Blackforest (portal.microsoftazure.de)
     Configration file name should be portal.microsoftazure.de.json

    ```xml
    <EmbeddedResource Include="Content\Config\portal.microsoftazure.de.json" />
    ```          

1. Fairfax (portal.azure.us)
    Configuration file name should be portal.azure.us.json
    
    ```xml
    <EmbeddedResource Include="Content\Config\portal.azure.us.json" />
    ```          

Environment configuration files server 2 purposes:

* Make the extension available in target environment

    Override settings for target environment. If there are no settings that needs to be overridden, the file should contain an empty json object. 


* The file content is a json object with key/value pairs for settings to be overridden. 

When the portal requests an extension, it passes the portal host name as a query string parameter to the extension. The hosting service reads this query string parameter and checks if the extension has provided a configuration file for that portal host name. If it does then the hosting service will load that file and will merge the settings defined in the file with the settings that are included in the extension home page. If a file does not exist for the portal host name, the hosting service will respond with a 400 bad request response code.

Updating content of config file

The portal framework expects the settings to be in the format of Microsoft.Azure.MyExtension.MySetting. The framework will propagate setting to the client in the format of mySetting. So to be able to provide a value for this setting, the web.config file should be something like

```xml
<add key="Microsoft.Azure.MyExtension.MySetting" value="myValue" />
```

The equivalent configuration file would like like:

```json
{
    "mySetting": "myValue"      
}
```

For example, if you have backend controllers that you would like to call from the client, you would add a property to your ApplicationConfiguration C# class that is called ControllerEndpoint.

You can find more information about propagating configuration to the client at [top-extensions-custom-domains.md](top-extensions-custom-domains.md).
 
Once you do that, you can provide a value to that property for each cloud by adding the property name in camel casing to the environment specific config file.

```json
{
   "controllerEndpoint":"https://mycontrollerendpoint.mybackendhostname.net"
}
```

<a name="30-sec-overview-step-by-step-onboarding-step-5-execute-content-unbundler-as-part-of-build-to-generate-zip-file"></a>
#### Step 5: Execute content unbundler as part of build to generate zip file

The tool will generate a folder and a zip file with a name same as the extension version. The folder will contain all content required to serve the extension.

**Build configuration**

Override any of the default configuration items for your build environment

* _ContentUnbundlerSourceDirectory_: Defaults to $(OutputPath). This needs to be set to the directory of the build output of your web project that contains your web.config and /bin dir 

* _ContentUnbundlerOutputDirectory_: Defaults to $(OutputPath). This is the output directory content unbundler will place the unbundled content, under this directory ContentUnbundler will create a folder name HostingSvc.

* _ContentUnbundlerRunAfterTargets_: Defaults to AfterBuild. This is used to sequence when the RunContentUnbundler target will run.  The value of this property will be used to set the RunContentUnbundler targets AfterTargets property. 

* _ContentUnbundlerExtensionRoutePrefix_: The prefix name of your extension e.g scheduler that is supplied as part of onboarding to the extension host.

* _ContentUnbundlerZipOutput_: Defaults to false. set to true to zip the unbunduled output that can be used for deployment.
    
For example this is the customized configuration for scheduler extension in CoreXT

```xml
  <PropertyGroup>
    <ContentUnbundlerSourceDirectory>$(WebProjectOutputDir.Trim('\'))</ContentUnbundlerSourceDirectory>
    <ContentUnbundlerOutputDirectory>$(BinariesBuildTypeArchDirectory)\HostingSvc</ContentUnbundlerOutputDirectory>
    <ContentUnbundlerExtensionRoutePrefix>scheduler</ContentUnbundlerExtensionRoutePrefix>
    <ContentUnbundlerZipOutput>true</ContentUnbundlerZipOutput>
  </PropertyGroup>
```

Outside of CoreXT, the default settings in the targets file should work for most cases. The only property that needs to be overriden is ContentUnbundlerExtensionRoutePrefix 

```xml
  <PropertyGroup>
    <ContentUnbundlerExtensionRoutePrefix>scheduler</ContentUnbundlerExtensionRoutePrefix>
  </PropertyGroup>
```

<a name="30-sec-overview-step-by-step-onboarding-step-6-upload-safe-deployment-config"></a>
#### Step 6: Upload safe deployment config

You will need to author this file. 

1. Property names in the config.json are case sensitive.

1. File name config.json is case sensitive.

In addition to the zip files, the hosting service expects a config file in the storage account. This config file is used to specify the versions that hosting service needs to download, process and serve.
The file should be called config.json and should have the below structure:

```json
{
    "$version": "3",
    "stage1": "1.0.0.5",
    "stage2": "1.0.0.4",
    "stage3": "1.0.0.3",
    "stage4": "1.0.0.2",
    "stage5": "1.0.0.1",
    "friendName": "2.0.0.0"
}
```

**$version**:  This is a mandatory attribute and should always be defined in config.json. This is the version of the current config.json schema. Hosting service requires extension developers to use the latest version i.e. 3. 

**stage(1-5)**: stage(1-5) are mandatory attributes and should always be defined in config.json with a valid version number assosciated with it.

Safe deployment requires extensions should be rolled out to all data centers in a staged manner. Out of the box hosting service provides extension the capability to rollout extension in 5 stages.
From extension developer's point of view the stages correspond to Datacenters:

```json
    "stage1": "centraluseuap"
    "stage2": "westcentralus"
    "stage3": "southcentralus"
    "stage4": "westus"
    "stage5": "*"
```

This essentially means that if a user request the extension to be loaded in portal. Then based on the nearest data center portal will decide which version of extension to load. For example, based on the above mentioned config.json if a user from Central US region requests to load Microsoft_Azue_MyExtension then hosting service will load the stage 1 version i.e. 1.0.0.5 to the user. However, if a user from Singapoer loads the extension then the user will be served 1.0.0.1 of the extension.

In addition to the 5 stages, you can add custom names to versions that you want to test but not serve to customers. We call them friendly names. You can define up tp a 100 friendly names in config.json. If more than 100 friendly names are defined in the config, the hosting service will fail to sync the extension and an IcM incident will be created against the owning team.

Friendly names should point to valid versions of your extension, and those versions should exist in the storage account.

Each of the properties defined in your config (stages and friendly names) get a unique url that you can use to access the version that it points to. For example, to load the version that is in stage1 above, the url would be
[https://myextension.hosting.portal.azure.net/myextension/stage1?l=en&trustedAuthority=portal.azure.com](https://myextension.hosting.portal.azure.net/myextension/stage1?l=en&trustedAuthority=portal.azure.com)

To load version 2.0.0.0 the url would be
[https://myextension.hosting.portal.azure.net/myextension/friendlyname?l=en&trustedAuthority=portal.azure.com](https://myextension.hosting.portal.azure.net/myextension/friendlyname?l=en&trustedAuthority=portal.azure.com)

<a name="30-sec-overview-step-by-step-onboarding-step-7-registering-your-extension-with-hosting-service"></a>
#### Step 7: Registering your extension with hosting service

Extensions that intend to use extension hosting service should publish the extracted deployment artifacts (zip file) that are generated during the build along with config.json to a public endpoint. 
Make sure that all the zip files and config.json are at the same level.

Once you have these files available on a public endpoint, file a request to register this endpoint using the following [link](https://aka.ms/extension-hosting-service/onboarding).

To onboard the extenion, please provide following information in RDTask:

1. Extension Name: 

    For example, Microsoft_Azure_Test

1. Public read-only endpoint for Dogfood: 

    For example, [https://mybizaextensiondf.blob.core.windows.net/extension](https://mybizaextensiondf.blob.core.windows.net/extension)

1. Public read-only endpoint for PROD:

    For example, [https://mybizaextensionprod.blob.core.windows.net/extension](https://mybizaextensionprod.blob.core.windows.net/extension)

Please submit your onboarding request [here](https://aka.ms/extension-hosting-service/onboarding)

Here is the SLA for onboarding [top-extensions-svc-lvl-agreements.md](top-extensions-svc-lvl-agreements.md).

<a name="30-sec-overview-registering-the-extension-in-azure-portal"></a>
### Registering the extension in Azure Portal

To load your extension in Portal it must be registered in portal config. More details on updating the portal config are located at [http://aka.ms/portalfx/config](http://aka.ms/portalfx/config).  If the extension does not exist yet, register it in the Portal as disabled.

```json
{
    "name": "Microsoft_Azure_MyExtension",
    "uri": "//hosting.onecloud.azure-test.net/myextension",
    "uriFormat": "//hosting.onecloud.azure-test.net/myextension/{0}",
    "disabled": true,
    ...
},
```

Sample extension registeration for Extensions.prod.json i.e. RC, MPAC and Prod environment

```json
{
    "name": "Microsoft_Azure_MyExtension",
    "uri": "//myextension.hosting.portal.azure.net/myextension",
    "uriFormat": "//myextension.hosting.portal.azure.net/myextension/{0}",
    "disabled": true,
    ...
},
```

<a name="30-sec-overview-converting-from-custom-deployment-to-a-hosting-service"></a>
### Converting from custom deployment to a hosting service

To minimize the probability of regression, use the following procedure to migrate an extension from custom deployment to a hosting service. For more information about custom deployment, see [top-extensions-custom-deployment.md](top-extensions-custom-deployment.md).

1. Change the uri format to use a hosting service in the PROD environment

    An example of a pull request for modifying the uriFormat parameter is located at [https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/c22b81463cab1d0c6b2c1abc803bc25fb2836aad?refName=refs%2Fheads%2Fdev](https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/c22b81463cab1d0c6b2c1abc803bc25fb2836aad?refName=refs%2Fheads%2Fdev).

1. Flight changes in MPAC

    An example of a pull request for a flighting extension in MPAC is located at [https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/be95cabcf7098c45927e3bb7aff9b5e0f65de341?refName=refs%2Fheads%2Fdev](https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/be95cabcf7098c45927e3bb7aff9b5e0f65de341?refName=refs%2Fheads%2Fdev).

1. Enable 100% traffic in MPAC and PROD

    An example of a pull request that enables 100% traffic without flighting for MicrosoftAzureClassicStorageExtension, and 100% traffic with flighting for Microsoft_Azure_Storage is located at [https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/b81b415411f54ad83f93d43d37bcad097949a4e3?refName=refs%2Fheads%2Fdev&discussionId=-1&_a=summary&fullScreen=false](https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/b81b415411f54ad83f93d43d37bcad097949a4e3?refName=refs%2Fheads%2Fdev&discussionId=-1&_a=summary&fullScreen=false). 

1. Enable flighting in MPAC

    The Azure Portal provides the ability to flight the MPAC customers to multiple editions of an extension. Traffic will be equally distributed between all registered configurations, or stamps. An example of a pull request is located at [https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/be95cabcf7098c45927e3bb7aff9b5e0f65de341?refName=refs%2Fheads%2Fdev](https://msazure.visualstudio.com/One/Azure%20Portal/_git/AzureUX-PortalFx/commit/be95cabcf7098c45927e3bb7aff9b5e0f65de341?refName=refs%2Fheads%2Fdev).

	*  Hosting service extension.pdl file
    
        To flight traffic to multiple stamps, register other stamps in flightUri. For example, the friendly name MPACFlightis used to flight traffic to another edition of an extension, as in the following example.

        ```json
        { 
            name: "Microsoft_Azure_MyExtension", 
            uri: "//myextension.hosting.portal.azure.net/myextension", 
            uriFormat: "//myextension.hosting.portal.azure.net/myextension/{0}", 
            feedbackEmail: "azureux-myextension@microsoft.com", 
            flightUris: [
                "//myextension.hosting.portal.azure.net/myextension/MPACFlight",
            ],
        }
        ```

<a name="30-sec-overview-deploying-a-new-version-of-extension"></a>
### Deploying a new version of extension

If you are using safe deployment then it is likely that you want to rollout a new version to a specific stage.

**NOTE**: Publishing a version to specific stage in safe deployment does not require a new build 

1. If the version to be published is not in the storage account 

    * Push the .zip file to storage account registered with hosting service

    * Update specific stage in config.json to this verion

1. If the version to be published is in the storage account 

    * Update specific stage in config.json to this verion

<a name="30-sec-overview-hosting-service-diagnostics"></a>
### Hosting Service diagnostics

The versions available in the Hosting Service can be seen by going to the following URL:

| Environment | Hosting service |
| ----------- | --------------- |
|  Dogfood | [https://hosting.onecloud.azure-test.net/api/diagnostics](https://hosting.onecloud.azure-test.net/api/diagnostics) |
|  MPAC |  [https://ms.hosting.portal.azure.net/api/diagnostics](https://ms.hosting.portal.azure.net/api/diagnostics) |
|  PROD |  [https://hosting.portal.azure.net/api/diagnostics](https://hosting.portal.azure.net/api/diagnostics) |
| Mooncake | [https://hosting.azureportal.chinacloudapi.cn/api/diagnostics](https://hosting.azureportal.chinacloudapi.cn/api/diagnostics) |
| Blackforest | [https://hosting.azure-api.de/api/diagnostics](https://hosting.azure-api.de/api/diagnostics)
| Fairfax |  [https://hosting.azureportal.usgovcloudapi.net/api/diagnostics](https://hosting.azureportal.usgovcloudapi.net/api/diagnostics) |

Each extension gets its own diagnostics endpoint, by adding the extension name to the path before `/api`. For example, [https://hosting.portal.azure.net/myextension/api/diagnostics](https://hosting.portal.azure.net/myextension/api/diagnostics).

<a name="30-sec-overview-friendly-names-and-sideloading"></a>
### Friendly names and sideloading

Friendly name allows you to test new versions of your extension before rolling them out to customers.

You can side load the version associated with the friendly name in the portal by specifying a couple of feature flags. For example, in the config above, if to load version 2.0.0.0 in the portal, you could using the below url

`https://portal.azure.com?feature.canmodifystamps&Microsoft_Azure_MyExtension=friendlyname`

1. `feature.canmodifystamps=true` is required for side-loading.

1. Replace `Microsoft_Azure_MyExtension` with unique name of extension defined in `extension.pdl`.

When those feature flags are passed to the portal, the portal will use the friendly name that is specified in the query string in combination with the value of the uriFormat property for that extension to generate a url that is unique for that friendly name. For example, based on the portal url above and the uriFormat defined, the portal will use the below url to load the extension.

`https://myextension.hosting.portal.azure.net/myextension/friendlyname?l=en&trustedAuthority=portal.azure.com&...`.


<a name="30-sec-overview-monitoring-and-logging"></a>
### Monitoring and Logging

<a name="30-sec-overview-monitoring-and-logging-logging"></a>
#### Logging

The portal provides a way for extensions to log to MDS using a feature that can be enabled in the extension.
More information about the portal logging feature can be found here [https://auxdocs.azurewebsites.net/en-us/documentation/articles/portalfx-telemetry-logging](https://auxdocs.azurewebsites.net/en-us/documentation/articles/portalfx-telemetry-logging).

The logs generated by the extension when this feature is enabled can be found in a couple of tables in the portal's MDS account.

<a name="30-sec-overview-monitoring-and-logging-trace-events"></a>
#### Trace Events

`https://ailoganalyticsportal-privatecluster.cloudapp.net/clusters/Azportal/databases/AzurePortal?query=ExtEvents%7Cwhere+PreciseTimeStamp%3Eago(10m)`

ExtEvents | where PreciseTimeStamp >ago(10m)

<a name="30-sec-overview-monitoring-and-logging-telemetry-events"></a>
#### Telemetry Events

`https://ailoganalyticsportal-privatecluster.cloudapp.net/clusters/Azportal/databases/AzurePortal?query=ExtTelemetry%7Cwhere+PreciseTimeStamp%3Eago(10m)`

ExtTelemetry | where PreciseTimeStamp >ago(10m)

<a name="30-sec-overview-monitoring-and-logging-monitoring"></a>
#### Monitoring

There are two categories of issues that need to be monitored for each extension and that partners can act on.

* Portal loading and running the extension

    The portal already has alerts setup to notify extensions of when it fails to load the extension for any reason. 

*  Hosting Service downloading and service the extension

    The hosting service will ping the endpoint where it expects to find the extension bits every minute. It will then download any new configurations and versions it finds. If it fails to download or process the downloaded files it logs these as errors in its own MDS tables. We get notified if any errors or warnings are generated by the hosting service. You can access the logs of the hosting service using the below link [https://jarvis-west.dc.ad.msft.net/53731DA4](https://jarvis-west.dc.ad.msft.net/53731DA4).

<a name="30-sec-overview-alerting"></a>
### Alerting

If the hosting service fails to sync an extension, an IcM incident will be created against the owning team.

The hosting service could fail to sync an extension for multiple reasons.

* Storage account is unavailable

* Config.json contains an invalid JSON object

* Some versions that are referenced in Config.json do not exist in the storage account

* Validation for one or more versions failed during sync

When you receive an incident, take a look at the error messages that appear in the log. 

If the error is caused by a change that you made, please fix the issue and wait for 15 minutes to give the hosting service time to pick up the new changes.

If you think the error is related to the hosting service, route the incident back to our team.

If the error is caused by an outage (for example storage outage or datacenter outage), wait until the root cause incident is resolved and then resolve the incident that was created against your team.



<a name="frequently-asked-questions"></a>
## Frequently asked questions

<!-- TODO:  FAQ Format is ###Link, ***title***, Description, Solution, 3 Asterisks -->

<a name="frequently-asked-questions-output-zip-file-incorrectly-named"></a>
### Output zip file incorrectly named

***When I build my project, the output zip is called HostingSvc.zip instead of \<some version>.zip.***

The primary cause of this issue is that your `web.config` appSetting for **IsDevelopmentMode** is `true`.  It needs to be set to `false`.  Most do this using a `web.Release.config` transform. For example,

```xml
    <?xml version="1.0" encoding="utf-8"?>

    <!-- For more information on using web.config transformation visit http://go.microsoft.com/fwlink/?LinkId=125889 -->

    <configuration xmlns:xdt="http://schemas.microsoft.com/XML-Document-Transform">
      <appSettings>
        <!-- dont forget to ensure the Key is correct for your specific extension -->
        <add key="Microsoft.Portal.Extensions.Monitoring.ApplicationConfiguration.IsDevelopmentMode" value="false" xdt:Transform="SetAttributes" xdt:Locator="Match(key)"/>
      </appSettings>
    </configuration>

```

* * * 

<a name="frequently-asked-questions-how-extensions-are-served"></a>
### How extensions are served

***How does hosting service serve my extension?***

The runtime component of the hosting service is hosted inside an Azure Cloud Service. When an extension onboards, a publicly accessible endpoint is provided by the extension developer which will contain the contents that the hosting service should serve. For the hosting service to pick them up, it will look for a file called `config.json` that has a specific schema described below. 

The hosting service will download the config file, and look into it to figure out which zip files it needs to download. There can be multiple versions of the extension referenced in the `config.json` file. The hosting service will download them and unpack them on the local disk. After it has successfully downloaded and expanded all versions of the extension referenced in `config.json`, it will write `config.json` to disk.

For performance reasons, once a version is downloaded, it will not be downloaded again. 

* * * 

<a name="frequently-asked-questions-rollout-time-for-stages"></a>
### Rollout time for stages

***How much time does hosting service take to rollout a new version of extension to the relevant stage?*** 

The hosting service takes about 5 minutes to publish the latest version to all data centers.

* * *

<a name="frequently-asked-questions-finding-old-ux-after-deployment"></a>
### Finding old UX After Deployment

***Some customers of my extension are finding the old UX even after deploying the latest package. Is there a bug in hosting service ?***

No this is not a bug. All clients will not get the new version as soon as it gets deployed. The new version is only served when the customer refreshes the Portal. We have seen customers that keep the Portal open for long periods of time. In such scenarios, when customer loads the extension they are going to get the old version that has been cached.
We have seen scenarios where customers did not refresh the Portal for 2 weeks. 

* * * 

<a name="frequently-asked-questions-speed-up-test-cycles"></a>
### Speed up test cycles

***My local build is slow. How can I speed up the dev/test cycles ?***

The default F5 experience for extension development remains unchanged however with the addition of the **ContentUnbundler** target some teams prefer to optimize to only run it on official builds or when they set a flag to force it to run.  The following example demonstrates how the Azure Scheduler extension is doing this within **CoreXT**.

```xml
    <PropertyGroup>
        <ForceUnbundler>false</ForceUnbundler>
    </PropertyGroup>
    <Import Project="$(PkgMicrosoft_Portal_Tools_ContentUnbundler)\build\Microsoft.Portal.Tools.ContentUnbundler.targets" 
            Condition="'$(IsOfficialBuild)' == 'true' Or '$(ForceUnbundler)' == 'true'" />
```

* * * 

<a name="frequently-asked-questions-content-unbundler-throws-aggregate-exception"></a>
### Content Unbundler throws aggregate exception

***Content Unbundler throws an Aggregate Exception during build.***

This usually happens when the build output generated by content unbundler is different from expected format.  The solution is as follows.

1. Verify build output directory is called **bin**
1. Verify you can point IIS to **bin** directory and load extension

For more information, see [top-extensions-hosting-service.md](top-extensions-hosting-service-basic.md).

* * *


<a name="frequently-asked-questions-zip-file-replaced-in-storage-account"></a>
### Zip file replaced in storage account

***What happens if instead of publishing new version to my storage account I replace the zip file ?***

Hosting service will only serve the new versions of zip file. If you replace version `1.0.0.0.zip` with a new version of `1.0.0.0.zip`, then hosting service will not detect.
It is required that you publish new zip file with a different version number, for example `2.0.0.0.zip`, and update `config.json` to reflect that hosting service should service new version of extension.

Sample config.json for version 2.0.0.0

```json
    {
        "$version": "3",
        "stage1": "2.0.0.0",
        "stage2": "2.0.0.0",
        "stage3": "2.0.0.0",
        "stage4": "2.0.0.0",
        "stage5": "2.0.0.0",
    }
```

**NOTE**: This samples depicts that all stages are serving version 2.0.0.0.

* * * 

<a name="frequently-asked-questions-storage-account-registration"></a>
### Storage account registration

***Do I need to register a new storage account everytime I need to upload zip file ?***

No. Registering a storage account with the hosting service is one-time process, as specified in . This allows the hosting service to find the latest version of your extension.

* * * 


<a name="frequently-asked-questions-other-hosting-service-questions"></a>
### Other hosting service questions

***How can I ask questions about hosting service ?***

You can ask questions on Stackoverflow with the tag [ibiza-deployment](https://stackoverflow.microsoft.com/questions/tagged/ibiza-deployment).

* * * 